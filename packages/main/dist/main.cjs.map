{"version":3,"file":"main.cjs","sources":["../src/util.ts","../../../node_modules/picomatch/lib/constants.js","../../../node_modules/picomatch/lib/utils.js","../../../node_modules/picomatch/lib/scan.js","../../../node_modules/picomatch/lib/parse.js","../../../node_modules/picomatch/lib/picomatch.js","../../../node_modules/picomatch/index.js","../../../node_modules/readdirp/index.js","../../common/const.ts","../src/image.ts","../../common/functions.ts","../src/IPC.ts","../src/menu.ts","../src/main.ts"],"sourcesContent":["import { URL } from \"url\";\nimport path from \"path\";\nimport { app } from \"electron\";\n\n\n/**\n * 获取入口文件的URL路径\n * @returns\n */\nexport function getEntryUrl(): string {\n  const devServerUrl: string | undefined = import.meta.env\n    .VITE_DEV_SERVER_URL as string;\n\n  // 开发环境返回http地址的url\n  if (import.meta.env.DEV && devServerUrl !== undefined) {\n    return devServerUrl;\n  } \n\n  // 正式环境返回文件路径\n  const url =  new URL('../renderer/dist/index.html', 'file://' + __dirname);\n  return url.toString();\n}\n\n/**\n * 获取资源路径\n * @param paths\n * @returns\n */\nexport function getAssetPath(...paths: string[]) {\n  const RESOURCES_PATH = app.isPackaged\n    ? path.join(process.resourcesPath, \"resources\")\n    : path.join(__dirname, \"../../resources\");\n\n  return path.join(RESOURCES_PATH, ...paths);\n}\n\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        output = token.close = `)${rest})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n","export enum AllowTypes {\n  JPG = \"image/jpeg\",\n  JPEG = \"image/jpeg\",\n  PNG = \"image/png\",\n  APNG = \"image/apng\",\n  WEBP = \"image/webp\",\n  GIF = \"image/gif\",\n  AVIF = \"image/avif\",\n  SVG = \"image/svg+xml\",\n}\n\nexport enum IPCEvents {\n  // 退出应用程序\n  QuitApp = \"QuitApp\",\n  // 最小化应用程序\n  MiniApp = \"MiniApp\",\n  // 添加图片列表\n  AddImages = \"AddImages\",\n  // 清空图片列表\n  EmptyImages = \"EmptyImages\",\n  // 清空完成\n  EmptyOver = \"EmptyOver\",\n  // 选取图片\n  PickImages = \"PickImages\",\n  // 状态更新\n  StatusUpdate = \"StatusUpdate\"\n}\n\nexport interface ImageItem {\n  // 0：完成压缩，1：正在压缩\n  status: 0 | 1;\n  path: string;\n  name?: string;\n  oldSize?: number;\n  newSize?: number;\n}\n\n","import { IpcMainEvent } from \"electron\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport readdirp from \"readdirp\";\nimport { AllowTypes, type ImageItem } from \"@common/const\";\n\n/**\n * 用来临时缓存所有的图片列表\n */\nexport const ImageList: Array<ImageItem> = [];\n\n/**\n * 清空图片列表\n * @param event \n */\nexport async function emptyImageList(event: IpcMainEvent){\n  ImageList.splice(0);\n  // 发送成功通知 TODO\n}\n\n/**\n * 根据提供的路径列表返回所有的图片文件\n * @param event \n * @param pathList \n * @returns \n */\nexport async function addImagesFromList(\n  event: IpcMainEvent,\n  pathList: ImageItem[]\n) {\n  const output: ImageItem[] = [];\n  // 如果不是目录，则判断是否是合法的图片文件\n  const types = Object.keys(AllowTypes);\n\n  // 验证文件的合法性，如果是图片，添加到输出中\n  const ensureImageLegal = (image: ImageItem): void => {\n    const extension = path.extname(image.path).toUpperCase().replace(/^\\./, \"\");\n    if (types.includes(extension)) {\n      let item: ImageItem = {\n        status: image.status,\n        path: image.path,\n        name: image.name,\n      };\n      if (!item.name) {\n        item.name = path.basename(image.path);\n      }\n      const stat = fs.lstatSync(item.path);\n      item.oldSize = stat.size;\n      output.push(item);\n    }\n  };\n\n  for (let item of pathList) {\n    const imagePath = item.path;\n    const isDir = fs.lstatSync(imagePath).isDirectory();\n    // 如果是目录，则遍历读取目录的所有文件信息\n    if (isDir) {\n      for await (const entry of readdirp(imagePath, { depth: Infinity })) {\n        ensureImageLegal({\n          status: item.status,\n          name: entry.basename,\n          path: entry.fullPath,\n        });\n      }\n      continue;\n    }\n    // 如果是文件，直接验证文件\n    ensureImageLegal(item);\n  }\n\n  return output;\n}\n","/**\n * 判断是否是mac平台\n * @returns \n */\nexport function isMac() {\n  return process.platform === \"darwin\";\n}\n\n/**\n * 判断是否是windows平台\n * @returns \n */\nexport function isWin() {\n  return process.platform === \"win32\";\n}\n\n/**\n * 判断是否是linux平台\n * @returns \n */\nexport function isLinux() {\n  return process.platform === \"linux\";\n}\n","import {\n  ipcMain,\n  app,\n  BrowserWindow,\n  IpcMainEvent,\n  dialog,\n  OpenDialogSyncOptions,\n} from \"electron\";\nimport { addImagesFromList, emptyImageList } from \"./image\";\nimport { type ImageItem, AllowTypes, IPCEvents } from \"@common/const\";\nimport { isMac } from \"@common/functions\";\n\nexport class IPC {\n  private _quitApp: IPCEventHandler;\n  private _miniApp: IPCEventHandler;\n  private _addImages: IPCEventHandler;\n  private _emptyImages: IPCEventHandler;\n  private _pickImages: IPCEventHandler;\n\n  /**\n   * 关闭App\n   */\n  private quitApp() {\n    app.quit();\n  }\n\n  /**\n   * 最小化App\n   */\n  private miniApp() {\n    this.win.minimize();\n  }\n\n  /**\n   * 选择图片，会弹出系统原生文件选择对话框\n   * @param event\n   */\n  private pickImages(event: IpcMainEvent) {\n    const extensions = Object.keys(AllowTypes).map((ext) => ext.toLowerCase());\n    // windows和linux下不支持同时选择文件和文件夹\n    const openProps: OpenDialogSyncOptions[\"properties\"] = [\"openFile\"];\n    if (isMac()) {\n      openProps.push(\"openDirectory\");\n    }\n    const result = dialog.showOpenDialogSync({\n      title: \"请选择待压缩的图片\",\n      filters: [{ name: \"图片类型\", extensions }],\n      properties: [\n        ...openProps,\n        \"multiSelections\",\n        \"showHiddenFiles\",\n        \"promptToCreate\",\n      ],\n    });\n\n    if (Array.isArray(result)) {\n      const list: ImageItem[] = result.map((item) => {\n        return {\n          status: 1,\n          path: item,\n        };\n      });\n      addImagesFromList(event, list);\n    }\n  }\n\n  /**\n   * 向图片列表中添加图片\n   * @param list\n   */\n  private addImages(event: IpcMainEvent, list: ImageItem[]) {\n    addImagesFromList(event, list);\n  }\n\n  /**\n   * 清空图片列表\n   */\n  private emptyImages(event: IpcMainEvent) {\n    emptyImageList(event);\n    event.reply(IPCEvents.EmptyOver);\n    event.reply(IPCEvents.EmptyOver);\n    event.reply(IPCEvents.EmptyOver);\n  }\n\n  constructor(public win: BrowserWindow) {\n    this._quitApp = this.quitApp.bind(this);\n    this._miniApp = this.miniApp.bind(this);\n    this._addImages = this.addImages.bind(this);\n    this._emptyImages = this.emptyImages.bind(this);\n    this._pickImages = this.pickImages.bind(this);\n  }\n\n  public bind() {\n    ipcMain.on(IPCEvents.QuitApp, this._quitApp);\n    ipcMain.on(IPCEvents.MiniApp, this._miniApp);\n    ipcMain.on(IPCEvents.AddImages, this._addImages);\n    ipcMain.on(IPCEvents.EmptyImages, this._emptyImages);\n    ipcMain.on(IPCEvents.PickImages, this._pickImages);\n  }\n\n  public unbind() {\n    ipcMain.off(IPCEvents.QuitApp, this._quitApp);\n    ipcMain.off(IPCEvents.MiniApp, this._miniApp);\n    ipcMain.off(IPCEvents.AddImages, this._addImages);\n    ipcMain.off(IPCEvents.EmptyImages, this._emptyImages);\n    ipcMain.off(IPCEvents.PickImages, this._pickImages);\n  }\n}\n","import { Menu, MenuItemConstructorOptions } from \"electron\";\n\nexport function createMenu() {\n  const submenu: MenuItemConstructorOptions[] = [\n    {\n      label: \"关于\",\n      role: \"about\",\n    },\n    {\n      label: \"退出\",\n      role: \"quit\",\n      accelerator: \"CommandOrControl+Q\",\n    },\n  ];\n  if (import.meta.env.DEV) {\n    submenu.push({\n      label: \"开发者工具\",\n      role: \"toggleDevTools\",\n      accelerator: \"CommandOrControl+Alt+I\",\n    });\n  }\n\n  const menu = Menu.buildFromTemplate([\n    {\n      label: \"图小小\",\n      submenu,\n    },\n  ]);\n\n  Menu.setApplicationMenu(menu);\n}\n","import path from 'path';\n\nimport { app, BrowserWindow, shell } from 'electron';\nimport { getEntryUrl,  getAssetPath } from './util';\nimport { IPC } from './IPC';\nimport { createMenu } from './menu';\n\n// 当前主窗口的引用\nlet mainWindow: BrowserWindow | null = null;\n\n/**\n * 创建一个应用程序窗口\n */\nasync function createWindow() {\n  // 创建一个窗口实例\n  mainWindow = new BrowserWindow({\n    show: false,\n    width: 800,\n    height: 600,\n    icon: getAssetPath('icon.png'),\n    // 窗口不可缩放\n    resizable: false,\n    // 无边框\n    frame: false,\n    maximizable: false,\n    roundedCorners: false,\n    titleBarStyle: 'hidden',\n    webPreferences: {\n      // 只有开发环境允许使用devtools\n      devTools: import.meta.env.DEV,\n      // 窗口预加载的资源文件\n      preload: path.join(__dirname, '../../preload/dist/index.cjs'),\n    },\n  });\n  // 伴随着window而创建的ipc通信逻辑\n  const ipc = new IPC(mainWindow);\n  ipc.bind();\n\n  // 窗口准备好了，显示窗口\n  mainWindow.on('ready-to-show', () => {\n    if (!mainWindow) {\n      throw new Error('\"mainWindow\" is not defined');\n    }\n    if (process.env.START_MINIMIZED) {\n      mainWindow.minimize();\n    } else {\n      mainWindow.show();\n    }\n  });\n\n  // 窗口被关闭，清理资源\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n    ipc.unbind();\n  });\n\n  // 加载窗口入口文件\n  await mainWindow.loadURL(getEntryUrl());\n\n  // 在本地浏览器窗口中打开链接请求\n  mainWindow.webContents.setWindowOpenHandler((details) => {\n    shell.openExternal(details.url);\n    return { action: 'deny' };\n  });\n}\n\n/**\n * 启动应用程序\n */\n(async () => {\n  createMenu();\n  // 当所有窗口都关闭时，退出app\n  app.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n      app.quit();\n    }\n  });\n\n  // 等待app就绪\n  await app.whenReady();\n  createWindow();\n\n  // 应用被激活时触发\n  app.on('activate', () => {\n    if (mainWindow === null) {\n      createWindow();\n    }\n  });\n})();\n"],"names":["app","path","require$$0","POSIX_REGEX_SOURCE","constants","require$$1","utils","scan","parse","require$$2","require$$3","require$$4","picomatch","fs","readdirp","dialog","Menu","BrowserWindow"],"mappings":"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"}